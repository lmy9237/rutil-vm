package com.itinfo.rutilvm.api.repository.engine.entity

import com.itinfo.rutilvm.common.gson
import org.hibernate.annotations.Type
import org.slf4j.LoggerFactory
import java.time.LocalDateTime
import java.util.UUID
import java.io.Serializable
import java.math.BigInteger
import javax.persistence.CascadeType
// Or jakarta.persistence.* for newer Spring Boot
import javax.persistence.Column
import javax.persistence.Entity
import javax.persistence.FetchType
import javax.persistence.GeneratedValue
import javax.persistence.GenerationType
import javax.persistence.Id
import javax.persistence.IdClass
import javax.persistence.JoinColumn
import javax.persistence.JoinTable
import javax.persistence.ManyToMany
import javax.persistence.ManyToOne
import javax.persistence.OneToMany
import javax.persistence.OneToOne
import javax.persistence.OrderBy
import javax.persistence.Table


data class NameServerId(
	var dnsResolverConfiguration: UUID? = null, // Corresponds to dns_resolver_configuration_id
	var address: String? = null                 // Corresponds to address
) : Serializable {
	// Default constructor, equals, and hashCode are automatically generated by data class
}
/**
 *
 * [NameServerEntity]
 * 이름있는 서버 정보
 *
 * @property id [UUID]
 * @property address [String]
 * @property dnsResolverConfiguration [DnsResolverConfigurationEntity]
 * @property position [Int]
 *
 * @see DnsResolverConfigurationEntity
 */
@Entity
@Table(name = "name_server")
@IdClass(NameServerId::class) // Specify the IdClass
class NameServerEntity(
	/*
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO) // Or IDENTITY if DB generates it and it's not UUID
	@Column(name = "id_placeholder") // Assuming there's an actual PK column, even if not explicitly listed by you.
	// If name_server's PK is a composite of (dns_resolver_configuration_id, position),
	// then the mapping is more complex with @IdClass or @EmbeddedId.
	// For now, let's assume a surrogate UUID PK 'id_placeholder' exists
	// or that you'll define the composite PK.
	// If 'dns_resolver_configuration_id' + 'position' IS the PK, skip this 'id' field.
	var id: UUID? = UUID.randomUUID(), // Or Long, or remove if composite PK
	*/
	// First part of the composite primary key: links to DnsResolverConfigurationEntity
	@Id
	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "dns_resolver_configuration_id", referencedColumnName = "id", nullable = false)
	var dnsResolverConfiguration: DnsResolverConfigurationEntity? = null,
	@Id
	@Column(name = "address", nullable = false, length = 45)
	var address: String = "",
	var position: Short? = 0,
): Serializable {
	override fun toString(): String =
		gson.toJson(this)

	override fun equals(other: Any?): Boolean {
		if (this === other) return true
		if (javaClass != other?.javaClass) return false
		other as NameServerEntity
		if (address != other.address) return false
		if (position != other.position) return false
		return true
	}

	override fun hashCode(): Int {
		var result = dnsResolverConfiguration?.id?.hashCode() ?: 0
		result = 31 * result + address.hashCode()
		return result
	}

	class Builder {
		private var bAddress: String = "";fun address(block: () -> String?) { bAddress = block() ?: "" }
		private var bDnsConfiguration: DnsResolverConfigurationEntity? = null;fun dnsConfiguration(block: () -> DnsResolverConfigurationEntity?) { bDnsConfiguration = block() }
		private var bPosition: Short? = 0;fun position(block: () -> Short?) { bPosition = block() ?: 0 }
		fun build(): NameServerEntity = NameServerEntity( bDnsConfiguration, bAddress, bPosition)
	}

	companion object {
		inline fun builder(block: Builder.() -> Unit): NameServerEntity = Builder().apply(block).build()
	}
}
